# 原始类型有几种？
 boolean null undefined number string symbol


# null 是对象吗?
   是
   0.1 + 0.2 ！= 0.3 精度丢失
   000 代码的是对象， null 的二进制都是0

# 原始类型和对象类型有什么差别？
  原始类型存的是值，对象类型存的是地址（指针）



# typeof能正确判断的类型是哪些？
  - typeof只能判断原始类型，null除外，除原始类型之外都默认为object
    typeof(null) 输出object
    typeof({}/[]) 输出object
  - instanceof 只能判断引用类型（对象类型），判断原始类型均为false

# 重写一个新的函数让 instanceof 也能判断原始类型

# 类型转换
  转为布尔值
  转为数字
  转为字符串
  - 对象转原始值
    对象在转类型的时候会调用内置的[[ToPrimitive]]
    - 如果已经是原始类型，那就不用转换
    - 调用x.valueOf() ,如果转为了基础类型，就返回值
    - 调用x.toString()，如果转为了基础类型，就返回值
    - 如果还没转为原始类型，就报错

# 四则运算
  + ：运算中其中一方为字符串，另一方一定会转换成字符串
      如果一方不是数字或字符串，那就会把它转换成数字或字符串进行运算

  除加法外的运算，只要其中一方是数字，另一方一定会转为数字来运算

# == 和 === 的区别
  1 == '1'
  1. 两者类型是否相同，相同的话就比大小
  2. 类型不同，那么就进行类型转换
  3. 会先判断是否在对比null 和undefined，是的话就会返回true
  4. 判读两者是否为string 和number，是的话就将string 转为number
  5. 判断其中一方是否为Boolean，只要其中一方有Boolean就把Boolean转为number
  6. 判断其中一方是否为object，且另一方为 string 或者 number 、symbol，是的话就把object 转为原始类型再进行判断
  [] == [] //false 引用类型是判断指针是否相同
  [] == ![] // true
    [] == !true
    [] == false
    [] == 0
    "" == 0
    0 == 0

# 什么是闭包？




# 深浅拷贝
  Object.assign（）如果拷贝的属性是原始值类型，那么是深拷贝；如果是引用类型，那么是浅拷贝。

  JSON.parse(JSON.stringify()) 的缺陷：
  1. 会忽略undefined
  2. 会忽略symbol
  3. 不能序列化函数
  4. 不能解决循环引用的对象

  - 什么是浅拷贝？如何实现？
    拷贝值类型的字段，拷贝的是内容（相互独立）；拷贝引用类型的字段，拷贝的是地址（相互影响）




  - 什么是深拷贝？如何实现？
    拷贝值类型的字段，拷贝的是内容（相互独立）；拷贝引用类型的字段，拷贝的也是内容（相互独立）