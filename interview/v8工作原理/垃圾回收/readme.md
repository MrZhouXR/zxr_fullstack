# 垃圾回收

1. 手动回收 （例如： c/ c++）
2. 自动回收  （例如：javascript，java，Python）

# 栈中的垃圾数据  和 堆中的垃圾数据 是怎么回收的


栈中的垃圾数据： 
   javascript：引擎会通过乡下移动esp（指针）来销毁函数保存在栈中的执行上下文

堆中的垃圾数据：


# 代际假说 和 分代假说

  代际假说（人为的一种认知）：
  1. 大部分对象在内存中存在的世界很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问
  2. 不死的对象会活的更久


v8  会把堆分成  新生代 和 老生代 两个区
    新生代： 存放生存时间短的对象  1 ~ 8M 的容量  被副垃圾回收器回收
    老生代： 存放生存时间长的对象 很大  被主垃圾回收器回收

# 垃圾回收器的工作流程
  不论什么类型的垃圾回收器，都有一套共同的执行流程
  1. 标记空间中的活动对象（还在使用的对象） 和 非活动对象（可以进行垃圾回收的对象）
  2. 回收非活动对象所占据的内存
  3. 做内存整理，频繁回收对象后，就会出现大量不连续的空间（内存碎片）

# 副垃圾回收器

  主要负责新生代的垃圾回收，通常情况下，大多数小的对象都会被分配到新生区，但是回收是很频繁的
  scavenge算法 会把新生区的内存一分为二，分为对象区域和空闲区域，然后标记对象区域里面所有的对象，把活对象复制到空闲区域，此过程还会做好排序，相当于做了内存整理，然后清空对象区域，两角色翻转

  当存活对象过多，新生区空间不够时，js会采用对象晋升策略，经过两次垃圾回收还存活的对象，直接移动到老生区

# 主垃圾回收器

  主要负责老生区的垃圾回收，老生区中的对象来自于新生区中晋升的对象和一些本身就很大的对象。

  标记-清除的算法，首先是标记阶段（递归遍历的去标记一组对象，但凡是能找到一个节点是活对象，那这组对象就是活对象，一个活对象节点都没有的成为垃圾数据

# 全停顿
  因为javascript是运行在v8的主线程上的，而垃圾回收的算法也在主线程，那么就会出现当需要垃圾回收时，js的运行会暂停。等垃圾回收完毕后再回复运行 ---  全停顿

  全停顿在新生区是没有太大的影响的，v8 将标记过程分成一个个子标记过程，同时让垃圾回收标记和js应用逻辑交替进行，知道标记完成（增量标记算法）
